
<!DOCTYPE html>
<html lang="" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>java容器 - DumboJ</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="DumboJ,"> 
    <meta name="description" content="Dumboj&#39;Blog,ArrayList1.概览：ArrayList基于数组实现，RandomAccess接口标识该类支持快速随机访问。public class ArrayList&amp;lt;E&amp;gt; extends Ab,"> 
    <meta name="author" content="Jun Qian"> 
    <link rel="alternative" href="atom.xml" title="DumboJ" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">DumboJ</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://dumboj.top"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">java容器</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">java容器</h1>
        <div class="stuff">
            <span>八月 09, 2019</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%AE%B9%E5%99%A8-list-set-map/" rel="tag">-容器 -list -set -map</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h5 id="1-概览：ArrayList基于数组实现，RandomAccess接口标识该类支持快速随机访问。"><a href="#1-概览：ArrayList基于数组实现，RandomAccess接口标识该类支持快速随机访问。" class="headerlink" title="1.概览：ArrayList基于数组实现，RandomAccess接口标识该类支持快速随机访问。"></a>1.概览：ArrayList基于数组实现，RandomAccess接口标识该类支持快速随机访问。</h5><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<p>数组默认初始大小为10</p>
<pre><code class="java">private static final int DEFAULT_CAPACITY = 10;
</code></pre>
<h5 id="2-扩容："><a href="#2-扩容：" class="headerlink" title="2.扩容："></a>2.扩容：</h5><p>添加元素时使用ensureCapacityInternal（）方法来保证容量足够，如果不够时，需要使用grow（）方法扩容，新容量的大小为旧容量的1.5倍。</p>
<p>扩容操作时需要调用Arrays.copyof()把原数组复制到新数组中，这个操作代价很高。因此最好在创建时ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<pre><code class="java">public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
&#125;

private void ensureCapacityInternal(int minCapacity) &#123;
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    &#125;
    ensureExplicitCapacity(minCapacity);
&#125;

private void ensureExplicitCapacity(int minCapacity) &#123;
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
&#125;

private void grow(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<h5 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h5><p>删除元素时需要调用System.arraycopy()将index+1后面的元素都复制到index上，该操作的时间复杂度为O(N),可以看出ArrayList删除元素的代价也很高。</p>
<pre><code class="java">public E remove(int index) &#123;
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
&#125;
</code></pre>
<h5 id="4-Fail-Fast"><a href="#4-Fail-Fast" class="headerlink" title="4.Fail-Fast"></a>4.Fail-Fast</h5><p>modeCount用来记录ArrayList结构发生变化的次数。结构发生变化是指ArrayList添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较前后的modeCount是否改变，改变了需要抛出ConcurrentModificationException</p>
<pre><code class="java">private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException&#123;
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) &#123;
        s.writeObject(elementData[i]);
    &#125;

    if (modCount != expectedModCount) &#123;
        throw new ConcurrentModificationException();
    &#125;
&#125;
</code></pre>
<h5 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5.序列化"></a>5.序列化</h5><p>ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，没必要全部进行序列化。</p>
<p>保存元素的数组elementData使用transient修饰，该关键字声明数组默认不会被序列化。</p>
<pre><code class="java">transient Object[] elementData; // non-private to simplify nested class access    
</code></pre>
<p>ArrayList实现了writteObject()和readObject来控制只序列化数组中有元素填充那部分内容。</p>
<pre><code class="java">private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException &#123;
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) &#123;
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) &#123;
            a[i] = s.readObject();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException&#123;
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) &#123;
        s.writeObject(elementData[i]);
    &#125;

    if (modCount != expectedModCount) &#123;
        throw new ConcurrentModificationException();
    &#125;
&#125;
</code></pre>
<h3 id="2-Vector"><a href="#2-Vector" class="headerlink" title="2.Vector"></a>2.Vector</h3><p>它的实现与ArrayList类似，但是它使用synchronized进行同步。</p>
<pre><code class="java">public synchronized boolean add(E e) &#123;
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
&#125;

public synchronized E get(int index) &#123;
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
&#125;
</code></pre>
<h4 id="与ArrayList比较"><a href="#与ArrayList比较" class="headerlink" title="与ArrayList比较"></a>与ArrayList比较</h4><ul>
<li>Vector是同步的，因此开销比ArrayList更大，访问速度更慢。最好使用ArrayList而不是Vector，因为同步操作完全可以由程序员自己来控制。</li>
<li>Vector每次扩容请求其大小的两倍（也可以通过构造函数来设置），ArrayList是1.5倍</li>
</ul>
<h5 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h5><ol>
<li><h5 id="使用Collections-synchroniedList-得到一个线程安全的ArrayList"><a href="#使用Collections-synchroniedList-得到一个线程安全的ArrayList" class="headerlink" title="使用Collections.synchroniedList();得到一个线程安全的ArrayList"></a>使用Collections.synchroniedList();得到一个线程安全的ArrayList</h5><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);
</code></pre>
</li>
<li><h5 id="并发包下的CopyOnWriteArrayList类"><a href="#并发包下的CopyOnWriteArrayList类" class="headerlink" title="并发包下的CopyOnWriteArrayList类"></a>并发包下的CopyOnWriteArrayList类</h5><pre><code class="java">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h6 id="读写分离："><a href="#读写分离：" class="headerlink" title="读写分离："></a>读写分离：</h6><p>写操作在复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束后，需要把原始数组指向新的复制数组。</p>
<pre><code class="java">public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;

final void setArray(Object[] a) &#123;
    array = a;
&#125;
</code></pre>
<pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) &#123;
    return (E) a[index];
&#125;
</code></pre>
<h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><p>CopyOnWriteArrayList在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<h6 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h6><ul>
<li>内存占用：写操作时需要复制一个新的数组，使得内存占用为原来的两倍。</li>
<li>数据不一致。读操作时不能读取实时性的数据，因为部分写操作还没同步到读数组中。</li>
</ul>
<p>所以CopyOnWriteArrayList不适合内存敏感以及实时性要求很高的场景。</p>
</li>
</ol>
<h3 id="3-LinkedList"><a href="#3-LinkedList" class="headerlink" title="3.LinkedList"></a>3.LinkedList</h3><h5 id="1-概览：基于双向链表实现，使用Node存储链表节点信息。"><a href="#1-概览：基于双向链表实现，使用Node存储链表节点信息。" class="headerlink" title="1.概览：基于双向链表实现，使用Node存储链表节点信息。"></a>1.概览：基于双向链表实现，使用Node存储链表节点信息。</h5><pre><code>private static class Node&lt;E&gt; &#123;
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
&#125;
</code></pre>
<p>每个链表存储了first和last指针。</p>
<pre><code>transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;
</code></pre>
<h5 id="2-与ArrayList比较"><a href="#2-与ArrayList比较" class="headerlink" title="2.与ArrayList比较"></a>2.与ArrayList比较</h5><ul>
<li>ArrayList基于动态数组实现，LinkedList基于双向链表实现</li>
<li>ArrayList支持随机访问，LinkedList不支持。</li>
<li>LinkedList在任意位置添加删除元素更快。</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h5 id="1-存储结构：内部包含一个Entry-类型的数组table"><a href="#1-存储结构：内部包含一个Entry-类型的数组table" class="headerlink" title="1.存储结构：内部包含一个Entry[]类型的数组table"></a>1.存储结构：内部包含一个Entry[]类型的数组table</h5><p>java1.7中使用</p>
<pre><code class="java">transient Entry[] table;
</code></pre>
<p>java1.8中使用</p>
<pre><code>transient Node&lt;K,V&gt;[] table;
</code></pre>
<p>Entry和Node存储着键值对，从源码中next可以看出Entry或Node都是一个链表。数组中的每个位置都都被当成一个桶，一个桶存放一个链表。</p>
<p>HashMap使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的键值对对象（Entry或Node）</p>
<h5 id="2-拉链法的工作原理："><a href="#2-拉链法的工作原理：" class="headerlink" title="2.拉链法的工作原理："></a>2.拉链法的工作原理：</h5><pre><code>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;K1&quot;, &quot;V1&quot;);
map.put(&quot;K2&quot;, &quot;V2&quot;);
map.put(&quot;K3&quot;, &quot;V3&quot;);
</code></pre>
<ul>
<li><p>新建一个HashMap，默认的大小为16</p>
</li>
<li><p>计算k1的hashCode为115，对16取模=3；k2,k3的hashCode为118，对16取模为6，</p>
<p>链表的插入方式是以头插法方式进行的，对应&lt;k3,v3&gt;应在链表头部，即&lt;k2，v2&gt;前</p>
</li>
</ul>
<h6 id="查找分为两步进行"><a href="#查找分为两步进行" class="headerlink" title="查找分为两步进行"></a>查找分为两步进行</h6><ol>
<li>根据需要查找的key值确定桶所在位置</li>
<li>在链表上顺序查找，时间幅度和链表长度成正比</li>
</ol>
<h5 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3.put操作"></a>3.put操作</h5><p>HashMap允许键为null的键值对。因无法确定null的哈希值，采用的是强制指定桶下标来存放。HashMap使用第0个桶存放键为null的键值对。</p>
<pre><code class="java">public V put(K key, V value) &#123;
    if (table == EMPTY_TABLE) &#123;
        inflateTable(threshold);
    &#125;
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
&#125;
//键为null的键值对put（）
private V putForNullKey(V value) &#123;
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;
        if (e.key == null) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;
    modCount++;
    addEntry(0, null, value, 0);
    return null;
&#125;
</code></pre>
<h5 id="4-扩容"><a href="#4-扩容" class="headerlink" title="4.扩容"></a>4.扩容</h5><p>设HashMap的长度为M，需要存储的键值对数量为N，如果哈希函数满足均匀性要求，则每条链表的长度为N/M。</p>
<p>因此，为了让查找的成本降低，应该让table也就是M尽可能大。HashMap采用动态扩容，根据N的数量来调整M的值，保证空间效率和时间效率。</p>
<p>扩容操作同样需要将oldTable的键值对重新插入newTable中，这一步很费时。</p>
<h5 id="5-重新计算桶下标"><a href="#5-重新计算桶下标" class="headerlink" title="5.重新计算桶下标"></a>5.重新计算桶下标</h5><p>扩容时需要把键值对重新放在对应的桶上。HashMap使用了一个特殊的机制，降低重新计算桶下标的操作。</p>
<p>假设原数组长度为16，扩容后的new capacity为32；</p>
<pre><code>capacity     : 00010000
new capacity : 00100000
</code></pre>
<p>对于一个key：</p>
<ul>
<li>它的哈希值如果在第5位上为0，则取模和之前得到的哈希值一致</li>
<li>如果为1，则得到的结果为原来的结果+16</li>
</ul>
<h5 id="6-链表转红黑树"><a href="#6-链表转红黑树" class="headerlink" title="6.链表转红黑树"></a>6.链表转红黑树</h5><p>JDK1.8后，当桶存储的链表的长度&gt;=8时，会将链表转换为红黑树。</p>
<h5 id="7-HashMap和HashTable的比较"><a href="#7-HashMap和HashTable的比较" class="headerlink" title="7.HashMap和HashTable的比较"></a>7.HashMap和HashTable的比较</h5><ul>
<li>HashTable使用synchronized进行同步，即HashTable是线程安全的</li>
<li>HashMap允许键为null</li>
<li>HashMap使用fail-fast迭代器</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的（扩容重新计算哈希值）</li>
</ul>
<h3 id="4-ConcurrentHashMap"><a href="#4-ConcurrentHashMap" class="headerlink" title="4.ConcurrentHashMap"></a>4.ConcurrentHashMap</h3><p><code>static final class HashEntry&lt;K,V&gt; &#123;     final int hash;     final K key;     volatile V value;     volatile HashEntry&lt;K,V&gt; next; &#125;</code></p>
<h5 id="ConcurrentHashMap和HashMap实现上类似。区别在于ConcurrentHashMap引入了分段锁（Segement）。"><a href="#ConcurrentHashMap和HashMap实现上类似。区别在于ConcurrentHashMap引入了分段锁（Segement）。" class="headerlink" title="ConcurrentHashMap和HashMap实现上类似。区别在于ConcurrentHashMap引入了分段锁（Segement）。"></a>ConcurrentHashMap和HashMap实现上类似。区别在于ConcurrentHashMap引入了分段锁（Segement）。</h5><p>每个Segment维护着几个HashEntry，多个线程可以同时访问不同分段锁上的桶，并发度更高（并发量即Segment的个数）</p>
<h5 id="Segment继承自ReentrantLock"><a href="#Segment继承自ReentrantLock" class="headerlink" title="Segment继承自ReentrantLock"></a>Segment继承自ReentrantLock</h5><p><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</code></p>
<p><code>private static final long serialVersionUID = 2249069246763182397L;</code></p>
<p><code>static final int MAX_SCAN_RETRIES =</code><br>    <code>Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</code></p>
<p>​    <code>transient volatile HashEntry&lt;K,V&gt;[] table;</code></p>
<p>​    <code>transient int count;</code></p>
<p>​    <code>transient int modCount;</code></p>
<p>​    <code>transient int threshold;</code></p>
<p>​    <code>final float loadFactor;</code></p>
<p><code>&#125;</code></p>
<h5 id="Segment定义"><a href="#Segment定义" class="headerlink" title="Segment定义"></a>Segment定义</h5><p><code>final Segment&lt;K,V&gt;[] segments;</code></p>
<h5 id="默认Segment的并发级别为16"><a href="#默认Segment的并发级别为16" class="headerlink" title="默认Segment的并发级别为16"></a>默认Segment的并发级别为16</h5><p><code>static final int DEFAULT_CONCURRENCY_LEVEL = 16;</code></p>
<h5 id="JDK-1-8-的改动"><a href="#JDK-1-8-的改动" class="headerlink" title="JDK 1.8 的改动"></a>JDK 1.8 的改动</h5><p>JDK1.7使用Segment分段锁机制来实现并发更新操作，核心类即Segment,继承自重入锁ReentrantLock,并发度等于Segment个数。</p>
<p>JDK1.8中使用CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized，同样在链表过长时会转换为红黑树。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h5 id="存储结构："><a href="#存储结构：" class="headerlink" title="存储结构："></a>存储结构：</h5><p>继承自HashMap,因此具有和HashMap一样的快速查找特性。</p>
<h6 id="内部维护一个双向链表，用来维护插入顺序或者LRU顺序。"><a href="#内部维护一个双向链表，用来维护插入顺序或者LRU顺序。" class="headerlink" title="内部维护一个双向链表，用来维护插入顺序或者LRU顺序。"></a>内部维护一个双向链表，用来维护插入顺序或者LRU顺序。</h6><pre><code class="java">/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p>accessOrder决定了顺序，默认为false,此时维护的是插入顺序</p>
<pre><code class="java">final boolean accessOrder;
</code></pre>
<p>LinkedHashMap最重要的是以下两个维护顺序的函数，会在put、get等方法中调用。</p>
<pre><code class="java">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;
void afterNodeInsertion(boolean evict) &#123; &#125;
</code></pre>
<h5 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h5><p>当一个节点被访问时，如果accessOrder为true,则会把这个节点移到链表尾部。即指定了LRU顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，链表首部是最久没访问的节点。</p>
<h5 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h5><p>put操作等操作之后执行，当removeOldestEntry（）为true时，会移除链表首部节点first</p>
<p>removeOldestEntry默认为false,如果要让它为true,需继承自LinkedHashMap并覆盖这个方法的实现。这是实现LRU缓存的核心，移除最近最久未使用的节点，保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<h5 id="实现LRU缓存的思路"><a href="#实现LRU缓存的思路" class="headerlink" title="实现LRU缓存的思路"></a>实现LRU缓存的思路</h5><p>a.继承LinkedHashMap</p>
<p>b.使用LinkedHashMap构造函数将accessOrder设置为true,开启LRU顺序。</p>
<p>c.覆盖removeOldestEntry（）实现，在节点多余MAX_ENTRY时，方法返回true，删除最近最久未使用的节点。</p>
<pre><code class="java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) &#123;
        return size() &gt; MAX_ENTRIES;
    &#125;

    LRUCache() &#123;
        super(MAX_ENTRIES, 0.75f, true);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();
    cache.put(1, &quot;a&quot;);
    cache.put(2, &quot;b&quot;);
    cache.put(3, &quot;c&quot;);
    cache.get(1);
    cache.put(4, &quot;d&quot;);
    System.out.println(cache.keySet());
&#125;
</code></pre>
<pre><code class="java">[3,1,4]
</code></pre>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><p>WeakHashMap的Entry继承自WeakReference,被weakReference关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap主要用来实现缓存，通过使用WeakHashMap来引用缓存对象，由JVM对这部分缓存进行回收。</p>
<pre><code class="java">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;
</code></pre>
<h5 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h5><p>Tomcat中的ConcurrentCache使用了WeakHashMap来实现缓存功能。</p>
<p>ConcurrentCache采取的是分代缓存：</p>
<ul>
<li><p>经常使用的对象放入eden中，eden用ConcurrentHashMap实现，不用担心会被回收。</p>
</li>
<li><p>不常用的放入longterm,longterm使用WeakHashMap实现，这些老对象会被垃圾回收器回收。</p>
</li>
<li><p>当调用get()时，先从eden获取，如果没有再到longterm获取，如果从longterm获取到就放入</p>
<p>eden中，保证经常被访问的节点不会被回收。</p>
</li>
<li><p>当调用put()时，如果eden的大小超过了size，那么将eden的所有对象都放入longterm中，利用虚拟机回收掉一部分不经常使用的对象。</p>
<pre><code class="java">public final class ConcurrentCache&lt;K, V&gt; &#123;

    private final int size;

    private final Map&lt;K, V&gt; eden;

    private final Map&lt;K, V&gt; longterm;

    public ConcurrentCache(int size) &#123;
        this.size = size;
        this.eden = new ConcurrentHashMap&lt;&gt;(size);
        this.longterm = new WeakHashMap&lt;&gt;(size);
    &#125;

    public V get(K k) &#123;
        V v = this.eden.get(k);
        if (v == null) &#123;
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        &#125;
        return v;
    &#125;

    public void put(K k, V v) &#123;
        if (this.eden.size() &gt;= size) &#123;
            this.longterm.putAll(this.eden);
            this.eden.clear();
        &#125;
        this.eden.put(k, v);
    &#125;
&#125;
</code></pre>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://sc1.111ttt.cn/2015/1/06/02/99021925549.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='46c465b787a3b9347cd6'
        data-cs='ca94721c3c4ac708ed575bb8aabe0a335ebcddcc'
        data-r='DumboJ.github.io'
        data-o='DumboJ'
        data-a='DumboJ'
        data-d='true'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
